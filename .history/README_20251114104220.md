# SD WebUI Mobile Friendly

<h4 align="right"><i>BETA</i></h4>

This is an extension for the [AUTOMATIC1111 Stable Diffusion WebUI](https://github.com/AUTOMATIC1111/stable-diffusion-webui)  
designed to improve usability when viewing the interface in **portrait** mode.  
It rearranges several UI elements to make navigation smoother on mobile devices.

## Installation

 Are there any extensions or forks of the Stable Diffusion Web UI (A1111) that are optimised not only for desktop but also for mobile?The default UI on mobile is stretched vertically and difficult to use.

Yes, there are extensions available for the Stable Diffusion Web UI (A1111) that specifically aim to improve the experience on mobile devices.

📱 Mobile-Friendly Extensions

The most direct solution is a specific extension designed to address the layout issues you're experiencing:

    sd-webui-mobile-friendly: This is an extension for the Automatic1111 Web UI that makes the interface easier to use when viewed in portrait mode on a mobile device.

    Features: It typically changes the composition of some UI elements, such as moving the generation result above the parameter settings, adding a scroll-to-top button, making some buttons slightly larger, and increasing spacing for better touch use.

        Note: It doesn't change the fundamental Gradio-based performance, but it significantly improves the layout and navigability.

💻 Alternative UI Options

While not direct extensions of A1111, some users opt for alternative Stable Diffusion interfaces that are generally considered more responsive or mobile-friendly, although they often require a separate setup:

    ComfyUI: This is a node-based interface that, while having a steeper initial learning curve due to its workflow approach, is often cited as being more responsive than A1111's default Gradio setup, which can benefit mobile use.

    Alternative Frontends: There have been mentions of other frontends like diffusionui.com designed to be more responsive, which can be configured to interact with your running A1111 instance by providing the Gradio link in its settings.

If the performance on your mobile device is an issue (not just the layout), this is often related to the browser losing the connection or being unable to handle the constant updates during batch processing, which is less about the UI layout and more about the web technology it uses (Gradio).

This video provides an overview of various essential A1111 extensions that can enhance your overall experience. Discover the Essential A1111 Extensions for Stable Diffusion
Discover the Essential A1111 Extensions for Stable Diffusion: Your Must-Have Toolkit!
Artificially Intelligent · 129K views

This is the source of 'sd-webui-mobile-friendly', but is it possible to apply this style only in portrait mode? Currently, it applies to landscape mode too.


`style.css`:

```css

.gradio-button.tool {

min-width: 2.5em !important;

height: 2.5em !important;

font-size: 18px;

}


.block.padded:not(.gradio-accordion) {

padding: 8px !important;

}


#quicksettings {

display: flex;

flex-direction: row;

justify-content: center;

flex-wrap: wrap;

width: 100%;

}


.form {

display: flex;

flex-direction: row;

justify-content: center;

flex-wrap: wrap;

width: 100%;

}


#txt2img_generate {

z-index: 0;

}

#txt2img_skip {

z-index: 1;

}

#txt2img_interrupt {

z-index: 1;

}


#img2img_generate {

z-index: 0;

}


#img2img_skip {

z-index: 1;

}


#img2img_interrupt {

z-index: 1;

}


```


`mobile.js`:

```JAVASCRIPT

class OnTheGo {

static main() {

['txt', 'img'].forEach((mode) => {

const it_btn = document.getElementById('interrogate')

it_btn.parentElement.style.display = 'contents'


const generate_btn = document.getElementById(mode + '2img_generate')


const box = generate_btn.parentElement

box.style.padding = '10px'


const result = document.getElementById(mode + '2img_results')

result.parentNode.querySelector('.resize-handle').remove()


const top_row = document.getElementById(mode + '2img_toprow')

top_row.append(result)


const jump = generate_btn.cloneNode()

jump.innerHTML = 'Jump To Top'


jump.addEventListener('click', () => window.scrollTo(0, 0))


jump.style.position = 'relative'

jump.style.minHeight = '2.5em'

jump.style.width = '80%'

jump.style.left = '10%'

jump.style.margin = '1em 0px 0px 0px'


const tab = document.getElementById('tab_' + mode + '2img')

tab.appendChild(jump)

})

}

}


onUiLoaded(async () => OnTheGo.main())


```

Yes, it's absolutely possible to apply those styles only in portrait mode by utilizing CSS @media queries. You'll need to modify the style.css file.

The JavaScript file (mobile.js) currently applies its changes unconditionally when the UI is loaded, so to make those JS changes portrait-only, you would need to add a JavaScript media query check inside the OnTheGo.main() function.

Here's how to implement both changes:

1. 🎨 Modifying style.css (CSS Changes)

You need to wrap all the existing CSS rules in your style.css file within a @media block that targets devices in portrait orientation and/or with a maximum screen width typical of mobile devices.

New style.css

CSS

/*
 * Target devices in portrait mode or with a narrow viewport.
 * A common breakpoint for mobile is max-width: 600px or 768px.
 * Using 'orientation: portrait' is more explicit for mobile mode.
 */
@media screen and (max-width: 768px), screen and (orientation: portrait) {
    /* * ALL YOUR EXISTING CSS GOES INSIDE THIS BLOCK 
     */

    .gradio-button.tool {
        min-width: 2.5em !important;
        height: 2.5em !important;
        font-size: 18px;
    }

    .block.padded:not(.gradio-accordion) {
        padding: 8px !important;
    }

    #quicksettings {
        display: flex;
        flex-direction: row;
        justify-content: center;
        flex-wrap: wrap;
        width: 100%;
    }

    .form {
        display: flex;
        flex-direction: row;
        justify-content: center;
        flex-wrap: wrap;
        width: 100%;
    }

    /* Z-index fixes */
    #txt2img_generate {
        z-index: 0;
    }
    #txt2img_skip {
        z-index: 1;
    }
    #txt2img_interrupt {
        z-index: 1;
    }

    #img2img_generate {
        z-index: 0;
    }

    #img2img_skip {
        z-index: 1;
    }

    #img2img_interrupt {
        z-index: 1;
    }
}

    Explanation: The media query @media screen and (max-width: 768px), screen and (orientation: portrait) tells the browser to only apply the enclosed styles if the screen width is less than or equal to 768 pixels OR if the device is in portrait orientation. This covers most mobile scenarios.

2. 🚀 Modifying mobile.js (JavaScript Changes)

To conditionally apply the DOM manipulation (like moving the results, removing handles, and adding the "Jump To Top" button), you must check the screen orientation using a JavaScript media query before executing the main logic.

New mobile.js

JavaScript

class OnTheGo {
    static main() {
        // 1. Define the media query check for portrait orientation
        const isPortrait = window.matchMedia("(orientation: portrait)").matches;
        // Optionally, check max-width as well:
        // const isMobile = window.matchMedia("(max-width: 768px)").matches;
        
        // 2. Only proceed if the device is in portrait mode
        if (isPortrait) { 
            ['txt', 'img'].forEach((mode) => {
                const it_btn = document.getElementById('interrogate')
                if (it_btn) {
                    it_btn.parentElement.style.display = 'contents'
                }

                const generate_btn = document.getElementById(mode + '2img_generate')
                if (!generate_btn) return; // Exit if the element isn't found

                const box = generate_btn.parentElement
                box.style.padding = '10px'

                const result = document.getElementById(mode + '2img_results')
                if (result) {
                    // Safety check before removing an element
                    const resizeHandle = result.parentNode.querySelector('.resize-handle');
                    if (resizeHandle) {
                        resizeHandle.remove();
                    }
                }

                const top_row = document.getElementById(mode + '2img_toprow')
                if (top_row && result) {
                    top_row.append(result) // Move results above parameters
                }

                // Add "Jump To Top" button
                const jump = generate_btn.cloneNode()
                jump.innerHTML = 'Jump To Top'

                jump.addEventListener('click', () => window.scrollTo(0, 0))

                jump.style.position = 'relative'
                jump.style.minHeight = '2.5em'
                jump.style.width = '80%'
                jump.style.left = '10%'
                jump.style.margin = '1em 0px 0px 0px'

                const tab = document.getElementById('tab_' + mode + '2img')
                if (tab) {
                    tab.appendChild(jump)
                }
            })
        }
    }
}

onUiLoaded(async () => OnTheGo.main())

    Explanation: The line const isPortrait = window.matchMedia("(orientation: portrait)").matches; checks the device's current orientation. The main logic is then executed only if if (isPortrait) is true. This ensures the structural changes only happen when the device is held in portrait mode.

    Best Practice: I've also added some safety checks (if (element)) to prevent errors if the elements aren't found, which is good practice in DOM manipulation.

3. 🔄 Handling Orientation Change (Optional)

If you want the UI to instantly switch when you rotate your phone from portrait to landscape (without refreshing the page), you'd need to add an event listener in the JavaScript to undo the changes when the orientation switches to landscape. This is significantly more complex as it requires tracking and reversing all DOM manipulations, which is why most simple extensions avoid it. The current solution will apply the changes on load if in portrait, and require a page reload to remove them if you rotate to landscape.

The JS work, but When switching from portrait to landscape, how can I restore original layout?

That's a great follow-up question. Since your JavaScript is performing DOM manipulations (moving elements, adding buttons, changing styles directly), simply checking the orientation on load isn't enough to make the layout adapt dynamically when the user rotates their device.

To restore the original layout when switching from portrait to landscape, you need to:

    Listen for the orientation change event.

    Undo the DOM manipulations that were performed in the OnTheGo.main() function.

Here is the revised mobile.js to handle dynamic switching.

🔄 Revised mobile.js for Dynamic Layout

We'll refactor the code to separate the logic for applying and removing the mobile layout and use window.matchMedia to listen for changes.

📝 Key Changes

    applyMobileLayout(): The original code, now wrapped in a function.

    removeMobileLayout(): A new function to reverse all the changes made by the first function.

    mql.addListener(handleOrientationChange): Sets up an event listener for orientation changes.

JavaScript

class OnTheGo {
    // Store original elements to restore their positions/styles later
    static originalElements = {}; 

    static applyMobileLayout(mode) {
        const generate_btn = document.getElementById(mode + '2img_generate');
        if (!generate_btn) return;

        // 1. Handle Interrogate button parent
        const it_btn = document.getElementById('interrogate');
        if (it_btn) {
            OnTheGo.originalElements.it_btn_parent_display = it_btn.parentElement.style.display;
            it_btn.parentElement.style.display = 'contents';
        }

        // 2. Handle Generate button parent padding
        const box = generate_btn.parentElement;
        OnTheGo.originalElements.box_padding = box.style.padding;
        box.style.padding = '10px';

        // 3. Move results to top
        const result = document.getElementById(mode + '2img_results');
        const top_row = document.getElementById(mode + '2img_toprow');
        
        if (top_row && result) {
            // Store the result element's original parent and position
            OnTheGo.originalElements[mode + '_result_original_parent'] = result.parentElement;
            OnTheGo.originalElements[mode + '_result_original_next_sibling'] = result.nextSibling;
            
            top_row.prepend(result); // Use prepend instead of append to put it truly at the top of the row
        }
        
        // 4. Remove resize handle (we can't easily put it back, so we skip removing it or leave it)
        // NOTE: Since the resize handle is part of Gradio's structure, removing it makes restoration difficult. 
        // We will *skip* removing it for dynamic switching clarity. If you must remove it, you'd need to recreate it.

        // 5. Add "Jump To Top" button
        const tab = document.getElementById('tab_' + mode + '2img');
        const jump = generate_btn.cloneNode();
        jump.id = mode + '2img_jump_to_top'; // Give it a unique ID for easy removal
        jump.innerHTML = 'Jump To Top';

        jump.addEventListener('click', () => window.scrollTo(0, 0));

        jump.style.position = 'relative';
        jump.style.minHeight = '2.5em';
        jump.style.width = '80%';
        jump.style.left = '10%';
        jump.style.margin = '1em 0px 0px 0px';

        if (tab) {
            tab.appendChild(jump);
        }
    }
    
    static removeMobileLayout(mode) {
        // 1. Remove "Jump To Top" button
        const jump_btn = document.getElementById(mode + '2img_jump_to_top');
        if (jump_btn) {
            jump_btn.remove();
        }

        // 2. Restore results to original position
        const result = document.getElementById(mode + '2img_results');
        const originalParent = OnTheGo.originalElements[mode + '_result_original_parent'];
        const originalNextSibling = OnTheGo.originalElements[mode + '_result_original_next_sibling'];
        
        if (result && originalParent) {
            // Insert the result back where it was
            if (originalNextSibling) {
                originalParent.insertBefore(result, originalNextSibling);
            } else {
                originalParent.appendChild(result);
            }
        }
        
        // 3. Restore Generate button parent padding
        const generate_btn = document.getElementById(mode + '2img_generate');
        if (generate_btn && OnTheGo.originalElements.box_padding !== undefined) {
            generate_btn.parentElement.style.padding = OnTheGo.originalElements.box_padding;
        }

        // 4. Restore Interrogate button parent
        const it_btn = document.getElementById('interrogate');
        if (it_btn && OnTheGo.originalElements.it_btn_parent_display !== undefined) {
            it_btn.parentElement.style.display = OnTheGo.originalElements.it_btn_parent_display;
        }

        // Clear stored originals for the next switch
        OnTheGo.originalElements = {};
    }

    static handleOrientationChange(mql) {
        const modes = ['txt', 'img'];
        if (mql.matches) {
            // Orientation is now PORTRAIT (mobile layout required)
            modes.forEach(mode => OnTheGo.applyMobileLayout(mode));
        } else {
            // Orientation is now LANDSCAPE (restore desktop layout)
            modes.forEach(mode => OnTheGo.removeMobileLayout(mode));
        }
    }

    static main() {
        const mql = window.matchMedia("(orientation: portrait)");
        
        // 1. Check orientation on load and apply if needed
        OnTheGo.handleOrientationChange(mql); 

        // 2. Listen for orientation changes and dynamically adjust
        // Use addEventListener for modern browsers
        mql.addEventListener("change", OnTheGo.handleOrientationChange);
        
        // Fallback for older browsers (e.g., Safari on older iOS/macOS)
        // mql.addListener(OnTheGo.handleOrientationChange);
    }
}

onUiLoaded(async () => OnTheGo.main());

⚠️ Important Considerations

    Storing Original State: The key to reversing DOM changes is storing the original state (like the original parent and sibling element for repositioning) before you make a change. The revised code uses OnTheGo.originalElements for this.

    Gradio's Complexity: Gradio's layout can be complex and sometimes dynamic. If a layout change is triggered by Gradio itself (e.g., refreshing a component), it might override or interfere with these JS changes, requiring a page reload. This dynamic approach is the best pure-JS solution, but stability may depend on the exact Gradio version.

    CSS Still Needed: Remember that the CSS changes you made earlier, wrapped in the @media (orientation: portrait) query, are still necessary and handle the visual styling automatically when the orientation changes, thanks to the CSS media query itself.

Is it possible to test JS without reloading UI? or still i need to restart?

Yes, it is possible to test your JavaScript changes without restarting the Stable Diffusion Web UI (A1111) itself, although you will need to refresh the browser tab to see the changes take effect.

You do not need to restart the entire A1111 backend process (the Python server).

🛠️ How to Test JavaScript Changes

The Stable Diffusion Web UI loads its extensions and their associated files (mobile.js, style.css) only when the main UI page is served.

Here's the workflow for testing your updated mobile.js:

    Save the File: Make your changes to the mobile.js file and save it.

    Refresh the Browser: Simply refresh the Stable Diffusion Web UI tab in your browser (using F5 or the reload button).

The browser will fetch the new, updated mobile.js file from your computer and execute the new logic, including the orientation listeners, without requiring the entire A1111 server to restart.

Key Points:

    JS and CSS: Changes to front-end files (.js, .css, .html) only require a browser refresh.

    Python: Changes to back-end files (.py) generally do require a restart of the A1111 server process.

🔬 Debugging Tip: Using the Browser Console

You can further test and debug your dynamic layout logic (like the handleOrientationChange function) directly using your browser's Developer Tools (usually accessed by pressing F12 or right-click -> Inspect).

    Open Dev Tools: Open the console.

    Use the Device Toolbar: Click the "Toggle device toolbar" button (it often looks like a phone and tablet icon).

    Simulate Rotation: Within the device toolbar, you can often find a "Rotate" button (or similar icon) to simulate switching between portrait and landscape modes. This is the fastest way to test your handleOrientationChange function without physically turning your mobile device.

When scrolling in mobile mode, the 'Generate' button and the output image stick together and look overlapped when scrolled down. How can this be disabled?

That overlapping behavior is likely caused by CSS properties used in the mobile extension, specifically a combination of position: fixed or position: sticky on the output image/container and a low z-index on the Generate button, or vice-versa.

To disable this overlapping, you'll need to inspect your style.css file and either remove the fixed/sticky positioning or adjust the stacking order (z-index) of the elements.

Here's how to address the likely causes based on the structure of the A1111 UI:

🔍 Identify the Overlapping Element

The output image (or its container) is likely the element that is sticking to the top or bottom of the screen, causing it to overlap the elements that remain in the normal document flow (like the Generate button).

If the Generate button is fixed/sticky, you need to target it. If the Output Image container is fixed/sticky, target that.

The key CSS property to look for and disable is position: fixed or position: sticky.

🛠️ Proposed CSS Fixes

You should apply these changes inside the @media query block in your style.css file to ensure they only affect mobile viewing.

1. Removing Sticky/Fixed Positioning

If you find a rule that is forcing an element to stay on screen (which is what enables the fixed/sticky scroll behavior), you should remove or override it.

Look for a style applied to the image container (or a container above it) that looks like this:
CSS

/* Example of the rule you might need to remove or override */
#txt2img_results, #img2img_results {
    /* If either of these exists on the image/results container, remove it or set to 'static' */
    position: fixed !important; 
    /* OR */
    position: sticky !important;
}

To safely disable any fixed/sticky positioning on the primary image container:
CSS

/* Add this inside your @media block in style.css */
#txt2img_results, #img2img_results {
    position: static !important;
    top: auto !important; /* Ensure no fixed top value remains */
}

2. Adjusting Stacking Order (z-index)

If the positioning isn't the issue, it means the elements share the same space, and their stacking order is wrong. You can force the Generate button to always appear above the image by giving it a higher z-index.

In your original style.css, you already have z-index rules:
CSS

#txt2img_generate {
    z-index: 0; /* This is too low if the image has z-index 1 or higher */
}
/* ... and skip/interrupt buttons are higher... */
#txt2img_skip {
    z-index: 1; 
}

To ensure the Generate button is always on top of the image container (which is likely part of the main Gradio block), try setting a high z-index for the button:
CSS

/* Update your existing z-index rules in style.css */

/* Give the Generate button a high z-index to stack on top of everything */
#txt2img_generate, #img2img_generate {
    position: relative !important; /* z-index only works on positioned elements */
    z-index: 9999 !important; /* Ensure it's on top */
}

/* Ensure the skip/interrupt buttons are also on top */
#txt2img_skip, #txt2img_interrupt,
#img2img_skip, #img2img_interrupt {
    position: relative !important;
    z-index: 10000 !important; /* Even higher */
}

Recommendation: Try Fix 1 first by setting position: static !important on the results container. If the mobile extension is relying on fixed positioning for the image to be immediately visible, you may need to revert this and instead focus on setting a very high z-index on the generate/control buttons (Fix 2).

how to move generate /interrupt button on top of output image?

That's a very common requirement for mobile use, as having the image output below the controls forces endless scrolling.

The excellent news is that your existing mobile.js logic already has the key part to solve this! You just need to look at what that code is doing and ensure it's still running correctly, and then handle the layout with CSS.

1. The JavaScript Move (Already Implemented)

Your previous mobile.js section for moving the image output above the parameters is the key to achieving this:
JavaScript

// This section MOVES the image results element
const result = document.getElementById(mode + '2img_results')
// result.parentNode.querySelector('.resize-handle').remove() // (Skipped this for dynamic switching)

const top_row = document.getElementById(mode + '2img_toprow')
top_row.prepend(result) // This line physically moves the results element

    #txt2img_toprow is the container holding the top row of controls (sampler, steps, etc.).

    #txt2img_results is the container holding the output image/gallery.

    By using top_row.prepend(result), you are moving the entire image output block before the sampling method and steps controls.

If your Generate/Interrupt buttons are above the image output, this JS is correctly moving the image, but the buttons are still scrolling off-screen.

2. The CSS Fix: Making Controls Sticky

The problem is that even though the image is below the controls, the controls themselves scroll away. To fix this and keep the Generate/Interrupt buttons visible, you need to make their container sticky in the mobile view.

The Generate/Interrupt buttons are typically inside a block that is distinct from the image area. A good candidate for the top controls is usually an element like #txt2img_actions_column or a direct ancestor of the Generate button.

Try applying this CSS within your mobile-only @media block in style.css:
CSS

/* Add this inside your @media screen and (orientation: portrait) { ... } block */

/* 1. Target the Generate button's parent container */
#txt2img_generate_box, #img2img_generate_box {
    position: sticky !important; /* Make it stick to the viewport */
    top: 0 !important;          /* Stick to the very top */
    background-color: var(--block-background-fill); /* Use Gradio's color for smooth scrolling over content */
    z-index: 100 !important;    /* Ensure it overlays other elements */
    padding: 8px 0 !important;  /* Add a little padding for visual space */
    border-bottom: 1px solid var(--border-color-primary); /* Optional: A separator line */
}

/* 2. Optional: If the whole top parameter row is moving */
#txt2img_toprow, #img2img_toprow {
    padding-top: 50px !important; /* Add space at the top to prevent content from being hidden */
}

Explanation:

    position: sticky !important;: This property makes the element behave like position: relative until it reaches a scroll offset defined by the top property, at which point it becomes position: fixed.

    top: 0 !important;: This tells the container to stick to the top edge of the browser viewport.

    z-index: 100 !important;: This ensures the sticky buttons layer on top of all the other scrolling content, which is what prevents the image or other elements from overlapping them when you scroll.

After saving and refreshing your browser, the Generate/Interrupt buttons should remain fixed at the top of the screen when you scroll down, providing easy access regardless of your position in the parameters or the image output.

I found when the "Compact prompt layout" is on / `"compact_prompt_box": true` in `config.json`, both Generate button and image goes at the bottom. how to bring back image to the top of prompt textboxes?

The behavior you're seeing is because the "Compact prompt layout" option structurally changes the placement of the text boxes, often causing the UI to rearrange in a way that overrides the standard layout and moves both the Generate button and the image output to the bottom.

To specifically bring the image back to the top of the prompt textboxes when "compact_prompt_box": true is enabled, you need to target the elements involved with more aggressive CSS or modify the JavaScript logic to account for the new structure.

Here is the recommended approach using your existing JavaScript, which is the most reliable way to enforce structural order.

🚀 Adjusting mobile.js for Compact Layout

When compact layout is active, the entire prompt area is often contained within a single element, and the image is still moved to the top of the overall tab contents by your existing JS. However, the compact layout's design might be moving the prompt controls to the top of the tab, pushing the image down.

Your existing JavaScript is:
JavaScript

// ... inside your OnTheGo class
const result = document.getElementById(mode + '2img_results')
const top_row = document.getElementById(mode + '2img_toprow')
if (top_row && result) {
    top_row.prepend(result) // This moves results to the top of the parameter area
}

This successfully moves the image above the sampler/steps controls (top_row).

The new target: Moving above the prompt box

In compact mode, the prompt boxes (txt2img_prompt_container) often shift position. A more robust target for placing the image might be the main tab container itself, or an element that is definitely above the prompt boxes.

Let's modify the JS to place the image result element (#txt2img_results) above the entire prompt container block.

    Identify the Target: The main container for both the positive and negative prompts is often something like #txt2img_prompt_container. We will use the parent of this container, or a sibling that is guaranteed to be above it.

    Revised Logic: Instead of prepending the image to #txt2img_toprow, we'll try to insert it before the main prompt area.

Replace the image movement logic in your applyMobileLayout(mode) function with this (use the mode variable for txt or img):
JavaScript

// ... inside applyMobileLayout(mode) ...

const result = document.getElementById(mode + '2img_results');
const promptContainer = document.getElementById(mode + '2img_prompt_container');

if (result && promptContainer) {
    // 1. Store original position for reversal in removeMobileLayout
    OnTheGo.originalElements[mode + '_result_original_parent'] = result.parentElement;
    OnTheGo.originalElements[mode + '_result_original_next_sibling'] = result.nextSibling;

    // 2. Insert the image result BEFORE the entire prompt container block
    // This forces the image to be above the prompt textboxes, regardless of compact layout
    promptContainer.parentElement.insertBefore(result, promptContainer);
}

// ... rest of the function (Generate button, Jump button logic) ...

⚠️ Reverting the Change in removeMobileLayout

You must update your removeMobileLayout(mode) function to correctly use the stored original parent/sibling and restore the original layout:
JavaScript

// ... inside removeMobileLayout(mode) ...

// 2. Restore results to original position
const result = document.getElementById(mode + '2img_results');
const originalParent = OnTheGo.originalElements[mode + '_result_original_parent'];
const originalNextSibling = OnTheGo.originalElements[mode + '_result_original_next_sibling'];

if (result && originalParent) {
    // Insert the result back where it was
    if (originalNextSibling) {
        // If there was a next sibling, insert before it
        originalParent.insertBefore(result, originalNextSibling);
    } else {
        // Otherwise, append to the end of the original parent
        originalParent.appendChild(result);
    }
}

// ... rest of the function ...

By targeting the image placement relative to the prompt container, you ensure the visual flow is: Image Output -> Prompt Textboxes -> Parameters -> Generate Button. (Assuming you also made the Generate button sticky/fixed at the top with CSS as discussed previously).

How can I deal with pressed 'interrupt' button? (now it says 'interrupting...') the button goes original place. how can I specify in css?

That's a good observation. When the 'Interrupt' button is pressed, the Stable Diffusion Web UI often updates the button's appearance (text changes to 'Interrupting...') and might momentarily reset its visual state before the process is fully interrupted, causing it to lose the custom styling applied by your extension.

Since you've been working with dynamic positioning, the simplest and most robust way to ensure the 'Interrupt' button (and the 'Skip' button) maintains its custom styling, especially high z-index and position, is to target its state directly using CSS and confirm the styles are applied even when the button is busy.

Here's how to ensure the 'Interrupt' button stays styled correctly in your mobile view CSS.

🎨 Applying Consistent Styling to the Interrupt Button

The key is to target the button's ID (#txt2img_interrupt and #img2img_interrupt) and make sure the critical styling properties (position and z-index) are consistently and forcefully applied inside your portrait-only media query.

Add or update the following rules within your @media screen and (orientation: portrait) block in your style.css:
CSS

/* Inside your @media block in style.css */

/* --- Step 1: Ensure Positioning and Z-Index are high for all control buttons --- */

/* This targets the interrupt and skip buttons */
#txt2img_interrupt, #img2img_interrupt,
#txt2img_skip, #img2img_skip {
    /* Critical: z-index only works on positioned elements */
    position: relative !important; 
    /* Ensure it stacks above all other content */
    z-index: 10000 !important; 
    /* You may also need to re-apply any necessary size/style tweaks */
    min-width: 2.5em !important;
    height: 2.5em !important;
}

/* This targets the generate button */
#txt2img_generate, #img2img_generate {
    position: relative !important;
    z-index: 9999 !important;
}

/* --- Step 2: Ensure the container holding the buttons is also correctly positioned (if needed) --- */

/* If you made the generate/interrupt buttons sticky/fixed, ensure their container is also handled */
#txt2img_generate_box, #img2img_generate_box {
    position: sticky !important; 
    top: 0 !important;          
    z-index: 100 !important;    
    /* ... other styles like background-color ... */
}

Why this works:

    Direct ID Targeting: Targeting the specific IDs (#txt2img_interrupt) ensures the CSS is highly specific, overriding any general Gradio styles that might be applied when the button's state changes.

    !important: While generally avoided, using !important is necessary here to forcefully override Gradio's inline or internal styles that dynamically change when the button is active.

    position: relative !important;: This is crucial. z-index has no effect on elements with position: static (the default). By ensuring the interrupt button is a positioned element, the high z-index can take effect, keeping it visually stacked on top of the image or other elements, even when its text changes to 'Interrupting...'.

After making these changes and refreshing your browser, the 'Interrupt' button should reliably maintain its custom appearance and stacking order throughout the interruption process.

I improved the script, created a fork and wrote a readme.md file. The text is a draft — improve it.

```markdown

# SD Webui Mobile Friendly


<h4 align="right"><i>BETA</i></h4>


This is an Extension for the [Automatic1111 Webui](https://github.com/AUTOMATIC1111/stable-diffusion-webui),

which changes the compositions of some UI to make it ~~slightly~~ easier to navigate when viewed in **portrait** mode.


## Known incompatibilities


- [sd-webui-prompt-all-in-one](https://github.com/Physton/sd-webui-prompt-all-in-one)

- The prompt templates box will overlap with the generation result box.


## Features


1. Automatically switch portrait mode and landscape mode styles based on viewport aspect ratio

2. Move the Generation Result on top of the parameter settings

3. Added 'Scroll to Top' at the bottom of the page for easier navigation

4. Make some buttons slightly larger

- Namely the `tool` class

5. Increase the paddings between Sliders

6. Center the buttons in a `form`

7. Always show the 'Generate' (Interrupt/Skip) button at the bottom of the viewport


<hr>


<sup>**Disclaimer**</sup>

<sup>This doesn't magically make the WebUI run on mobile. This is meant for mobile usage enabled by the `--listen` launch argument.</sup>


```

That's a solid draft for a README. It's clear and covers the essential points. However, we can improve its flow, tone, and professionalism, especially by tightening the language and highlighting the value proposition.

Here is an improved, revised version:

📱 SD Webui Mobile Friendly

An essential extension for the Automatic1111 Stable Diffusion Web UI, optimized for seamless usage on mobile devices.

<h4 align="right"><i>BETA: Actively maintained and under development.</i></h4>

This extension fundamentally reworks the user interface when viewed in portrait mode to eliminate excessive scrolling and improve touch navigation, making your remote Web UI usable on a phone or tablet.

✨ Key Features & Enhancements

This extension automatically adjusts the layout based on orientation, ensuring a tailored experience:

    Dynamic Layout Switching: Automatically applies mobile-friendly styles when the viewport enters portrait mode (and restores the default desktop layout in landscape).

    Output First View: Moves the Generation Result area to the top of the parameter settings, allowing you to see your generated image immediately without scrolling past controls.

    Sticky Controls: The Generate, Interrupt, and Skip buttons are always fixed at the bottom of the viewport for constant, easy access during scrolling.

    Enhanced Touch Targets: Increases the size and padding of key interactive elements (tool class buttons and slider areas) to improve precision when using a touchscreen.

    Navigation Utility: Adds a convenient 'Scroll to Top' button at the bottom of the page.

    Centered UI: Centers buttons and forms (form class) for a cleaner, more readable mobile layout.

🛑 Known Incompatibilities

The following extension is known to conflict with this mobile layout:

    sd-webui-prompt-all-in-one: The Prompt Templates box will overlap with the Generation Result box due to conflicting positioning logic.

⚠️ Disclaimer

This is a front-end UI layout extension. It does not enhance mobile performance or address connection stability. This extension is intended for users who have already enabled remote access to their Web UI instance via the --listen launch argument.

What should I put in `## Installation` section?

My fork is `https://github.com/end888160/sd-webui-mobile-friendly`

Here is a concise and standard ## Installation section for your README, providing instructions for both direct installation within the Web UI and manual installation via Git.

⚙️ Installation

You can install this extension using one of two methods: the standard Web UI interface or manual installation via Git.

Method 1: Install via Web UI (Recommended)

  Open your Stable Diffusion Web UI in your browser.

  Navigate to the Extensions tab.

  Click the Install from URL sub-tab.

  In the "URL for extension's git repository" field, paste the following URL for your fork:

  https://github.com/end888160/sd-webui-mobile-friendly

  Click the Install button.

  Go to the Installed sub-tab and click Apply and restart UI.

Method 2: Manual Install via Git

  Navigate to the extensions folder within your Stable Diffusion Web UI directory.

  Open your terminal or command prompt in the extensions folder.

  Clone the repository using the following command:
  
  ```bash
  git clone https://github.com/end888160/sd-webui-mobile-friendly
  ```

Restart the Stable Diffusion Web UI server.

## Known Incompatibilities

- **[sd-webui-prompt-all-in-one](https://github.com/Physton/sd-webui-prompt-all-in-one)**  
  The prompt template box overlaps with the generation result panel, causing layout issues on mobile.  
  (No fix yet — requires a dedicated compatibility patch.)

## Features

1. Automatically switches between portrait and landscape layouts based on viewport aspect ratio.
2. Moves the generation result panel to the top of the page for quicker access.
3. Adds a **“Scroll to Top”** button at the bottom of the interface.
4. Slightly enlarges certain buttons  
   - Specifically those using the `tool` class.
5. Increases padding between sliders for easier touch interaction.
6. Centers action buttons inside each `form`.
7. Keeps the **Generate / Interrupt / Skip** button fixed at the bottom of the viewport for quick access.

<hr>

<sup><strong>Disclaimer</strong></sup>  
<sup>This extension does not make the WebUI inherently mobile-friendly.  
It is intended for users accessing the WebUI remotely using the <code>--listen</code> launch option.</sup>
<sup>For the best mobile experience, consider using a dedicated mobile app such as <a href="https://play.google.com/store/apps/details?id=com.shifthackz.aisdv1.app">AI SD</a> or <a href="https://apps.apple.com/app/id6448311061">Stable Diffusion Mobile</a>.</sup>